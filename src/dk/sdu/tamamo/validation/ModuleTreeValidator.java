/*
 * generated by Xtext 2.24.0
 */
package dk.sdu.tamamo.validation;

import org.eclipse.xtext.validation.Check;

import dk.sdu.tamamo.moduleTree.ChildTree;
import dk.sdu.tamamo.moduleTree.Conclusion;
import dk.sdu.tamamo.moduleTree.ConclusionElse;
import dk.sdu.tamamo.moduleTree.Decision;
import dk.sdu.tamamo.moduleTree.Input;
import dk.sdu.tamamo.moduleTree.InputString;
import dk.sdu.tamamo.moduleTree.ModuleTreePackage;
import dk.sdu.tamamo.moduleTree.Parameter;
import dk.sdu.tamamo.moduleTree.ParentTree;
import dk.sdu.tamamo.moduleTree.RuleLogic;
import dk.sdu.tamamo.moduleTree.ChildTree;
import dk.sdu.tamamo.moduleTree.RuleType;
import dk.sdu.tamamo.moduleTree.RuleTypeExp;
import dk.sdu.tamamo.moduleTree.RuleTypeID;
import dk.sdu.tamamo.moduleTree.Rules;
import dk.sdu.tamamo.moduleTree.Start;
import dk.sdu.tamamo.moduleTree.TreeType;



/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class ModuleTreeValidator extends AbstractModuleTreeValidator {
	
	@Check
	public void checkNoIntBool(Rules rule) {

		if (rule.getRule().getLeft() instanceof RuleTypeExp) {
			if (rule.getRule().getRight() == null) {
				error("Int cannot be the only parameter.", rule.eContainingFeature(), ModuleTreePackage.RULE_LOGIC__LEFT);
			}
		}
	}

	@Check
	public void checkNotBothArgumentsInts(Rules rule) {
		if (rule.getRule().getLeft() instanceof RuleTypeExp && rule.getRule().getRight() instanceof RuleTypeExp) {
			error("Please rewrite expression to an Input and an integer", rule.eContainingFeature(),
					ModuleTreePackage.RULE_LOGIC__LEFT);
		}
	}
//	@Check
//	public void checkInputExist(TreeType start) {
//		Input input = start.getInput();
//		Rules rule = start.getRules();
//
//		HelperMethod(rule.getRule(), input);
//
//		while ((rule = rule.getNext()) != null) {
//			HelperMethod(rule.getRule(), input);
//		}
//	}
	
//	@Check
//	public void checkParameterExist(TreeType tree) {
//		Parameter param = tree.getParameter();
//		Conclusion conc = tree.getConclusion();
//		System.out.println("inside checkParamExist");
//		HelperMethod(conc.getRule(), param);
//		while ((conc = conc.getNext()) != null) {
//			HelperMethod(conc.getRule(), param);
//		}
//	}
	
//	private void HelperMethod(RuleLogic rule, Parameter input) {
//
//		RuleType left = rule.getLeft();
//		boolean error = true;
//
//		if (left instanceof RuleTypeID) {
//
//			String rule_name = ((RuleTypeID) left).getName();
//
//			if (input.getName().equals(rule_name)) {
//				error = false;
//			}
//
//			while ((input = input.getNext()) != null && error) {
//				if (input.getName().equals(rule_name)) {
//					error = false;
//				}
//			}
//			if (error) {
//				error("Conclusion name is not a parameter.", rule, null,
//						ModuleTreePackage.RULE_LOGIC__LEFT);
//			}
//
//		}
//
//		RuleType right = rule.getRight();
//		if (right instanceof RuleTypeID && error) {
//			String rule_name = ((RuleTypeID) right).getName();
//
//			if (input.getName().equals(rule_name)) {
//				error = false;
//			}
//
//			while ((input = input.getNext()) != null && error) {
//				if (input.getName().equals(rule_name)) {
//					error = false;
//				}
//			}
//			if (error) {
//				error("Conclusion name is not a parameter.", rule, null,
//						ModuleTreePackage.RULE_LOGIC__RIGHT);
//			}
//
//		}
//	}

//	private int HelperMethod(RuleLogic rule, Parameter input) {
//
//		RuleType left = rule.getLeft();
//		boolean error = true;
//
//		if (left instanceof RuleTypeID) {
//
//			String rule_name = ((RuleTypeID) left).getName();
//			System.out.println(input.getName());
//			System.out.println(rule_name);
//
//			if (input.getName().equals(rule_name)) {
//				error = false;
//			}
//
//			while ((input = input.getNext()) != null && error) {
//				if (input.getName().equals(rule_name)) {
//					error = false;
//				}
//			}
//			if (error) {
//				System.out.println("inside error");
//				return -1;
//			}
//
//		}
//
//		RuleType right = rule.getRight();
//		if (right instanceof RuleTypeID && !error) {
//			String rule_name = ((RuleTypeID) right).getName();
//
//			if (input.getName().equals(rule_name)) {
//				error = false;
//			}
//
//			while ((input = input.getNext()) != null && error) {
//				if (input.getName().equals(rule_name)) {
//					error = false;
//				}
//			}
//			if (error) {
//				return 1;
//			}
//
//		}
//		return 0;
//	}
	
	@Check
	public void noDuplicateName(Start start) {
		TreeType parent = start.getParent();
		do {
			TreeType next = parent.getNext();
				do {
					if (parent.getModule_name().equals(next.getModule_name())) { 
						error("No duplicate tree name", next, next.eContainingFeature(), ModuleTreePackage.TREE_TYPE__MODULE_NAME); 
					} 
					//noDuplicateInputHelper((ParentTree) parent, child);
				} while ((next = next.getNext()) != null);
			
		} while ((parent = parent.getNext()) != null);
	}
	
//	@Check
//	public void ensureElse(Conclusion current) {
//		boolean elseExist = false;
//		do {
//			if (current instanceof ConclusionElse) {
//				elseExist = true;
//				System.out.println("breaking");
//				break;   
//			}
//		} while ((current = current.getNext()) != null);
//		if (!elseExist) {
//			error("You must include a default decision using the else keyword in the conclusion.", 
//					current, current.eContainingFeature(), ModuleTreePackage.CONCLUSION ); 
//		}
//	}
	
	@Check
	public void noBooleanConclusion(Conclusion conclusion) {
		if (conclusion.getRule().getRight() == null) {
			error("Conclusion cannot be written as a single boolean", 
					conclusion.getRule(), null, ModuleTreePackage.RULE_LOGIC);
		}
	}
	
	
	@Check
	public void noDuplicateInput(Start start) {
		TreeType parent = start.getParent();
		do {
			TreeType next = parent.getNext();
			if (parent instanceof ParentTree) {
				do {
					if (next instanceof ChildTree) {
						ChildTree child = (ChildTree) next;
						Input current_child = child.getInput();
						do { 
							  Input current_parent = parent.getInput(); 
							  do { 
								  if (current_child.getValue().getName().equals(current_parent.getValue().getName())) { 
									  error("No duplicate input", current_child, current_child.eContainingFeature(), 
											  ModuleTreePackage.INPUT__VALUE); 
								  } 
							  } while ((current_parent = current_parent.getNext()) != null); 
						  } while ((current_child = current_child.getNext()) != null); 
						//noDuplicateInputHelper((ParentTree) parent, child);
					} 
				} while ((next = next.getNext()) != null);
			}
			
		} while ((parent = parent.getNext()) != null);
	}
	
	
	
}
